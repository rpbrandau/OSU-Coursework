/*
 * Name: Riley Brandau
 * Class: CS_344
 * Program: brandaur.adventure.c
 * Due Date: 2/13/17
 * Description: Short adventure game using the files generated by brandaur.buildrooms.c
 *              Unfortunately, I was unable to complete all of the requirements, specifically
 *              the Time/mutex portion.
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <time.h>
#include <pthread.h>


//defining some global constants
#define MIN_ROOM_CONNECTIONS 3
#define MAX_ROOM_CONNECTIONS 6
#define NUM_OF_ROOMS 7

//Struct that will hold all of the room's information
struct Room
{
   const char *name;
   const char *roomType;
   int maxCon;
   int curCon;
   struct Room *connectedRooms[MAX_ROOM_CONNECTIONS];
};

//prototypes
struct Room *readRoom(const char *roomFile, const char *folder);
void assembleDungeon(struct Room **rooms, const char *folder);
void adventureTime(struct Room **rooms);
const char *playerInterface(struct Room *dungeon);
void releaseRooms(struct Room **rooms);
const char *newestFolder();

int main()
{
   int i = 0;
   const char *newFolder;
   struct Room *roomArray[NUM_OF_ROOMS];
   newFolder = newestFolder();
   assembleDungeon(roomArray, newFolder);
   adventureTime(roomArray);
   releaseRooms(roomArray);

   return 0;
}


/*
 * Reads room files and compares them to possible movements.
 */
struct Room *readRoom(const char *roomFile, const char *folder)
{
   struct Room *dungeon = malloc(sizeof(struct Room));
   char complete[100];                                                                      //making a variable to hold the entire file path
   memset(complete, '\0', sizeof(complete));
   strcpy(complete, folder);                                                               //copying the folder path
   //printf("After strcpy complete holds: %s\n", complete);
   strcat(complete, "/");                                                                    //adding a / to the path
   strcat(complete, roomFile);                                                           //adding the file to the path
   //printf("after strcat complete holds: %s\n", complete);
   char row[50];
   char userInput[50];
   int i = 0;
   int counter = 0;
   FILE *readFrom = fopen(complete, "r");                                        //opening the file to read it
  
   //if(access(complete, F_OK) != -1){
   while(fgets(row, sizeof(row), readFrom) != NULL)                                    //Read room file line by line         
   {
      if(strncmp(row, "ROOM NAME", 9) == 0)                                            //Compare the row to ROOM NAME
      {
         sscanf(row, "ROOM NAME: %s\n", userInput);
         char *temp = malloc(strlen(userInput));
         strcpy(temp, userInput);
         dungeon->name = temp;
         //printf("temp contains: %s\n", temp);
         //free(temp);
      }
      else if(strncmp(row, "CONNECTION", 9) == 0)                                      //Compare to CONNECTION
      {
         dungeon->connectedRooms[counter] = malloc(sizeof(struct Room));
         sscanf(row, "CONNECTION %d: %s\n", &i, userInput);
         char *temp = malloc(strlen(userInput));
         strcpy(temp, userInput);
         dungeon->connectedRooms[counter]->name = temp;
         counter++;
         //printf("temp contains: %s\n", temp);
         //free(temp);
      }
      else                                                                             //Compare to ROOM TYPE
      {
         sscanf(row, "ROOM TYPE: %s\n", userInput);
         char *temp = malloc(strlen(userInput));
         strcpy(temp, userInput);
         dungeon->roomType = temp;
         //printf("temp contains: %s\n", temp);
         //free(temp);
      }
   }
 
   
   dungeon->curCon = counter;
   fclose(readFrom);
   
   return dungeon;
 //  }else{ 
   // printf("File not found\n");
    //exit(0);
   //}
}


/*
 * Grabs room file names for the game to use
 */
void assembleDungeon(struct Room **rooms, const char *folder)
{
   
   int index = 0;
   const char *roomFile;
   DIR *directory;
   struct dirent *dir;
   directory = opendir(folder);                                   //opens the newest room folder

   if(directory)
   {
      while((dir = readdir(directory)) != NULL)          //reads all the files in the folder
      {
         if(dir->d_name[0] != '.')                                //ignores files starting with '.'
         {
            roomFile = dir->d_name;
            //printf("RoomFile: %s\n", roomFile);
            rooms[index] = readRoom(roomFile, folder);   //passes info to readRoom function, which then stores information in the roomArray
            index++;
         }
      }
   }
   closedir(directory);
}

const char *newestFolder()
{   
   //Code provided from piazza for determining newest directory
   int i = 0;
   char *folder = "brandaur.rooms.";                                  //base folder for rooms
   char currentDir[100];
   memset(currentDir, '\0', sizeof(currentDir));
   getcwd(currentDir, sizeof(currentDir));                           //get the current working directory
   printf("%s\n", currentDir);
   DIR *d;
   struct dirent *dp;
   struct stat *buffer;
   buffer = malloc(sizeof(struct stat));
   dp = malloc(sizeof(struct dirent));
   time_t lastModified = 0;
   char *newestFolder;
   d = opendir(currentDir);                                                  //opens the current directory
   if(d != NULL)
   {
      while(dp = readdir(d))                                                 //stores info in the dirent structure
      {
         if(strstr(dp->d_name, folder) != NULL)                    //while there's info to be read
         {
            stat(dp->d_name, buffer);                
            if(lastModified < buffer->st_mtime)                      //determining which is the newest folder by creation time
            {
               lastModified = buffer->st_mtime;
               newestFolder = dp->d_name;
            }
            if(lastModified == buffer->st_mtime)                    //this went unused
            {
              // printf("Newest folder:\n");
              // printf("%s: %s\n", dp->d_name, ctime(&lastModified));
              // printf("%s: %d\n", dp->d_name, lastModified);
            }
         }
      }
   }
   //printf("Newest folder: %s\n", newestFolder);              //debug
   return newestFolder;
}

 

/*
 * Function that controls flow of game
 */
void adventureTime(struct Room **rooms)
{
   struct Room *currentRoom;
   int playerPath[50];
   int i = 0;
   int index = 0;
   int steps = 0;
   const char *userInput;
   /* 
   for(i = 0; i < NUM_OF_ROOMS; i++)
   {
      userInput = rooms[i]->name;
      printf("AT room: %s\n", userInput);
   }
   printf("AT count: %d\n", i);
   */
  // userInput = rooms[0]->name;                                                             
   do                                                                                      //start of the game
   {
      if(steps == 0)
      {
         for(i = 0; i < NUM_OF_ROOMS; i++)                                                 //places the player in the starting room
         {
            if(strcmp(rooms[i]->roomType, "START_ROOM") == 0)
            {
               currentRoom = rooms[i];
            }
         }
      }
      else                                                                                //checks to see if player selection is valid
      {
         for(i = 0; i < NUM_OF_ROOMS; i++)
         {
            if(strcmp(rooms[i]->name, userInput) == 0)
            {
               currentRoom = rooms[i];
               playerPath[steps - 1] = i;
            }
         }
      }
     // if(strcmp(userInput, "time") == 0)                                                   //print out time, well, it would have, if I hadn't gotten hung up on other stuff.
     // {
     //    printf("Placeholder for current time.\n");
     // }
      if(strcmp(currentRoom->roomType, "END_ROOM") == 0)                                  //player completed the game
      {
         printf("You escaped! Hooray!\n");
         printf("You took %d steps, and the path you took was: \n", steps);        //displays how many steps and the path the player took
         for(i = 0; i < steps; i++)
         {
            index = playerPath[i];
            printf("%s\n", rooms[index]->name);
         }
      }
      else
      {
         userInput = playerInterface(currentRoom);                                             //uses the user's input from playerInterface
         steps++;
      }
   }while(strcmp(currentRoom->roomType, "END_ROOM") != 0);
}



const char *playerInterface(struct Room *dungeon)
{
   char userInput[40];                                                     //array to store user input. Sufficient to hold a room name.
   int io = 0;           
   int i = 0;
   int lastC = 0;                                                          //used to find the last character the user input
   const char *dungeonName;

   do                                                                      //loop until the user makes a valid input
   {
      printf("\n");
      printf("CURRENT LOCATION: %s\n", dungeon->name);                     //display player's whereabouts and options
      printf("POSSIBLE CONNECTIONS: ");
      
      for(i = 0; i < dungeon->curCon; i++)
      {
         if((i + 1) < dungeon->curCon)                                     //if this isn't the last i, print the dungeon name and a comma
         {
            printf("%s, ", dungeon->connectedRooms[i]->name);
         }
         else                                                              //if this is the last i, print the dungeon name and a period
         {
            printf("%s.\n", dungeon->connectedRooms[i]->name);
         }
      }
      
      printf("WHERE TO? > ");
      fgets(userInput, 40, stdin);
      //printf("You typed: %s", userInput);
      lastC = strlen(userInput) - 1;
      if(userInput[lastC] == '\n')                                        //gets rid of the '\n' character from user input.
      {
         userInput[lastC] == '\0';
      }
      
      for(i = 0; i < dungeon->curCon; i++)                               
      {
         dungeonName = dungeon->connectedRooms[i]->name;
         if(strncmp(userInput, dungeonName, lastC) == 0)                          //test to see if user's input matches a connected room
         {
            io = 1;
            return dungeon->connectedRooms[i]->name;
           //printf("Dungeon Names checked: %s, ", dungeonName);
         }
         /*
         else
         {
            printf("\n");
            printf("HUH? I DON'T UNDERSTAND THAT ROOM. TRY AGAIN. \n");
         }
         */
      }
      
      if(io == 0)
      {
         printf("\n");
         printf("HUH? I DON'T UNDERSTAND THAT ROOM. TRY AGAIN. \n");
      }
      printf("\n");
      
   }while(io == 0);
   //return dungeon->connectedRooms[i]->name;
} 


/*
 * Free memory allocated to rooms
 */
void releaseRooms(struct Room **rooms)
{
   int i = 0;
   for(i = 0; i < sizeof(rooms) - 1; i++)
   {
      free(rooms[i]);
   }
}
 
